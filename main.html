<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animated Grid Fill</title>
    <style>
      body {
        font-family: sans-serif;
        text-align: center;
        background-color: #222;
        color: white;
      }
      #controls {
        margin: 1em 0;
      }
      input {
        width: 80px;
        padding: 0.3em;
        border-radius: 5px;
        border: none;
        text-align: center;
      }
      button {
        padding: 0.4em 0.8em;
        border: none;
        border-radius: 6px;
        background: #4caf50;
        color: white;
        cursor: pointer;
        font-size: 1em;
        margin-left: 5px;
      }
      button:hover {
        background: #45a049;
      }
      canvas {
        border: 1px solid white;
        background: #111;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <h2>Canvas Grid Generator</h2>
    <div id="controls">
      <label
        >Canvas Width: <input id="canvasWidth" type="number" value="1000"
      /></label>
      <label
        >Canvas Height: <input id="canvasHeight" type="number" value="1000"
      /></label>
      <label>Columns: <input id="cols" type="number" value="5" /></label>
      <label>Rows: <input id="rows" type="number" value="5" /></label>
      <button onclick="drawGrid()">Draw Grid</button>
      <button onclick="fillTiles()">Fill Tiles</button>
      <button onclick="createMaze()">Create Maze</button>
    </div>

    <canvas id="gridCanvas" width="1000" height="1000"></canvas>

    <script>
      let gridData = [];
      let animationRunning = false;

      function drawGrid() {
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");

        const cols = parseInt(document.getElementById("cols").value);
        const rows = parseInt(document.getElementById("rows").value);
        const width = parseInt(document.getElementById("canvasWidth").value);
        const height = parseInt(document.getElementById("canvasHeight").value);

        canvas.width = width;
        canvas.height = height;
        ctx.clearRect(0, 0, width, height);

        const colWidth = width / cols;
        const rowHeight = height / rows;

        gridData = { cols, rows, colWidth, rowHeight, width, height };

        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1;

        // Vertical lines
        for (let i = 0; i <= cols; i++) {
          const x = i * colWidth;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }

        // Horizontal lines
        for (let j = 0; j <= rows; j++) {
          const y = j * rowHeight;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      async function fillTiles() {
        if (animationRunning || !gridData.cols) return;
        animationRunning = true;

        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");
        ctx.lineWidth = 0.1;
        const { cols, rows, colWidth, rowHeight } = gridData;

        let i = 0;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            // Pick a color
            const hue = (c / cols) * 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;

            // Fill the tile
            ctx.fillRect(c * colWidth, r * rowHeight, colWidth, rowHeight);

            // Redraw grid line
            ctx.strokeStyle = "#222";
            ctx.strokeRect(c * colWidth, r * rowHeight, colWidth, rowHeight);

            // Delay for animation effect
            await new Promise((resolve) => setTimeout(resolve, 40)); // 40ms per tile
          }
        }

        animationRunning = false;
      }

      function gridFast() {
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");
        const { cols, rows, colWidth, rowHeight } = gridData;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            // Pick a color
            const hue = (c / cols) * 360;
            ctx.fillStyle = `hsl(100, 70%, 100%)`;

            // Fill the tile
            ctx.fillRect(c * colWidth, r * rowHeight, colWidth, rowHeight);
          }
        }
      }

      async function createMaze() {
        animationRunning = true;

        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");
        const { cols, rows, colWidth, rowHeight } = gridData;
        gridFast();

        // define the datastructure here
        g = [];
        set = [];
        for (let r = 0; r < rows; r++) {
          g[r] = [];
          for (let c = 0; c < cols; c++) {
            g[r][c] = [true, true, true, true];
            set[rows * r + c] = [rows * r + c];
          }
        }

        // set inital openings of maze
        open = { x: 0, y: 0 };
        end = { x: cols - 1, y: rows - 1 };

        // Change inital openings of maze
        g[open.x][open.y][0] = false;
        g[end.x][end.y][1] = false;

        while (!isConnected(set, rows, cols)) {
          set = removeBorder(g, set, rows, cols);
          console.log(set);
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              // Pick a color
              const hue = (c / cols) * 360;
              ctx.fillStyle = `hsl(100, 70%, 100%)`;

              // Fill the tile
              ctx.fillRect(c * colWidth, r * rowHeight, colWidth, rowHeight);

              drawTileBorders(ctx, c, r, g[r][c]);

              // Delay for animation effect
              await new Promise((resolve) => setTimeout(resolve, 0)); // 40ms per tile
            }
          }
        }

        while (animationRunning) {
          break;
        }

        animationRunning = false;
      }

      async function drawTileBorders(ctx, c, r, cell) {
        const { colWidth, rowHeight } = gridData;
        const x = c * colWidth;
        const y = r * rowHeight;

        const gap = 2; // pixels of gap between tiles
        const gx = x + gap / 2;
        const gy = y + gap / 2;
        const gColWidth = colWidth - gap;
        const gRowHeight = rowHeight - gap;

        ctx.beginPath();
        ctx.strokeStyle = "black"; // make lines fully black
        ctx.lineWidth = 2; // make lines thicker (try 3â€“4 for even bolder)

        if (cell[0]) {
          // left
          ctx.moveTo(gx, gy);
          ctx.lineTo(gx, gy + gRowHeight);
        }
        if (cell[1]) {
          // right
          ctx.moveTo(gx + gColWidth, gy);
          ctx.lineTo(gx + gColWidth, gy + gRowHeight);
        }
        if (cell[2]) {
          // top
          ctx.moveTo(gx, gy);
          ctx.lineTo(gx + gColWidth, gy);
        }
        if (cell[3]) {
          // bottom
          ctx.moveTo(gx, gy + gRowHeight);
          ctx.lineTo(gx + gColWidth, gy + gRowHeight);
        }

        ctx.stroke();
      }

      function removeBorder(g, set, rows, cols) {
        const random_x = Math.floor(Math.random() * rows);
        const random_y = Math.floor(Math.random() * cols);
        const random_side = Math.floor(Math.random() * 4);
        console.log(`x: ${random_x}, y: ${random_y}, side: ${random_side}`);

        // edge checks
        if (
          (random_side === 0 && random_y === 0) || // left edge
          (random_side === 1 && random_y === cols - 1) || // right edge
          (random_side === 2 && random_x === 0) || // top edge
          (random_side === 3 && random_x === rows - 1) // bottom edge
        ) {
          return set;
        }

        // remove the wall on this tile
        g[random_x][random_y][random_side] = false;
        const tileNum = random_x * rows + random_y;
        let changeNum;
        // remove the corresponding wall on the neighbor tile
        if (random_side === 0) {
          // left
          g[random_x][random_y - 1][1] = false;
          changeNum = random_x * rows + random_y - 1;
        } else if (random_side === 1) {
          // right
          g[random_x][random_y + 1][0] = false;
          changeNum = random_x * rows + random_y + 1;
        } else if (random_side === 2) {
          // top
          g[random_x - 1][random_y][3] = false;
          changeNum = (random_x - 1) * rows + random_y;
        } else if (random_side === 3) {
          // bottom
          g[random_x + 1][random_y][2] = false;
          changeNum = (random_x + 1) * rows + random_y;
        }
        // Disjoint set logic
        let l;
        let r;

        for (let i = 0; i < set.length; i++) {
          if (set[i].includes(changeNum)) {
            l = i;
          }
          if (set[i].includes(tileNum)) {
            r = i;
          }
        }
        if (l === r && l !== undefined) {
          return set;
        }
        set[l] = [...set[l], ...set[r]];
        set.splice(r, 1);
        return set;
      }

      function isConnected(set, rows, cols) {
        for (let i = 0; i < set.length; i++) {
          if (
            set[i].includes(0) &&
            set[i].includes(rows * (rows - 1) + cols - 1)
          ) {
            return true;
          }
        }

        return false;
      }

      // Draw initial grid
      drawGrid();
    </script>
  </body>
</html>
